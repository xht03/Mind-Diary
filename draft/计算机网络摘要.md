---
title: 计算机网络·摘要
date: 2024-02-07 14:41:06
tags:
- original
categories:
- Computer Network
---

### 何为计算机网络

#### 定义

目前还没有一个严格的定义，这里可以作如下理解：把分布在不同地理位置上的具有独立功能的多台计算机、终端及其附属设备在物理上互连，按照网络协议相互通信，以共享硬件、软件和数据资源为目的的系统称作计算机网络。

---

#### 数据交换

数据交换技术一般分为一下三种：

- **线路交换**：通过网络中的结点在两个站之间建立一条专用的通信线路。（比如电话系统。在通话之前，通过用户的呼叫，如果呼叫成功，则从主叫端到被叫端就建立了一条物理通路，这样双方就能进行通话，当通话结束后双方挂机，这时为进行通话所建立起来的物理通路就自动拆除。）
- **报文交换**：对一些实时性要求不高的信息，可以采用报文交换。报文交换方式传输的单位是报文，在报文中包括要发送的正文信息和指明收发站的地址及其它控制信息。在报文交换中， 不需要在两个站之间建立一条专用通路。相反，发送站只要把一个目的地址附加在报文上，然后发送整个报文即可。报文从发送站到接收站，中间要经过多个结点，在这每个中间结点中，都要接收整个报文，暂存这个报文，然后转发到下一个结点。
- **报文分组交换**：是国际上计算机网络普遍采用的数据交换方式。发送站把一个要传送的报文分成若干段，每一段都作为报文分组的数据部分。由于报文分组交换允许每个报文分组走不同的路径，所以一个完整的报文分组还必须包括地址、分组编号、校验码等传输控制信息。 

线路交换安全性很高，不易监听和截获数据包；但是相对的成本高。报文交换成本虽低，但是中转站点都接收到完整的数据包，安全性低。报文分组交换则综合前两者的优点，成本低，且每个中转站点都只接受到部分数据包内容，安全性较高。

---

#### 网络拓扑结构

计算机网络拓扑结构一般有以下六种：

- 星型拓扑结构
- 总线型拓扑结构
- 环形拓扑结构
- 树型拓扑结构
- 全互连型拓扑结构
- 混合型拓扑结构：比较常见的有 *星型总线* 拓扑和 *星型环* 拓扑。

|     拓扑结构     |                      图示                      |
| :--------------: | :--------------------------------------------: |
|   星型拓扑结构   |   <img src="stars.png" style="zoom:25%;" />    |
|  总线型拓扑结构  |   <img src="buses.png" style="zoom:25%;" />    |
|   环形拓扑结构   |  <img src="circles.png" style="zoom:25%;" />   |
|   树型拓扑结构   |   <img src="trees.png" style="zoom:25%;" />    |
| 全互连型拓扑结构 |    <img src="alls.png" style="zoom:25%;" />    |
|  混合型拓扑结构  | <img src="congreted1.png" style="zoom:25%;" /> |

---

#### 类型

计算机网络一般分为一下两类：

- 局域网LAN（local area network）
- 广域网WAN（wide area network）





### 网络的体系结构

#### 层次

层次是人们对复杂问题处理的基本方法。将总体要实现的很多功能分配在不同层次中，对每个层次要完成的服务及服务要求都有明确规定。基本地：

- 不同的系统分成相同的层次
- 不同系统的最低层之间存在着“物理” 通信
- 不同系统的对等层次之间存在着“虚拟” 通信
- 对不同系统的对等层之间的通信有明确的通信规定
- 高层使用低层提供的服务时，并不需要知道低层服务的具体实现方法

最重要的是 **OSI参考模型**：它将计算机网络通信划分成了七个层次。（*有时为了简化：应用层+表示层+会话层，合称应用层* ）

![OSI](OSI.png)

---

#### 接口

接口是同一结点内相邻层之间交换信息的连接点。同一个结点的相邻层之间存在着明确规定的接口，低层向高层通过接口提供服务。（*只要接口条件不变、低层功能不变，低层功能的具体实现方法与技术的变化不会影响整个系统的工作* ）

---

#### 协议

网络协议是为网络数据交换而制定的规则、约定与标准。  





### 计算机如何通信

#### 通俗理解

- 在现实中，我们如果要给对方写信，除了信件内容以外，我们还需要填写信封。信封有两个重要信息，一个是收件地址，另一个是收件人。收件地址表示这封信要寄到哪里，收件人表示信要寄给谁。同理，在网络世界中，我们如果要发信息给别人，同样需要收件地址和收件人，而这里就是MAC地址和IP地址。**MAC地址就是收件地址，IP地址就是收件人**。

<img src="mac.png"  />

- 如果把网络比作我们生活的城市，**网卡就是我们居住的一栋栋建筑，MAC地址就是这栋建筑的物理地址，而IP地址就是住在这些建筑里的人**。不同于写信，在计算机网络中发送信息，我们只需要填写内容和对方的IP地址。操作系统会通过查询ARP表自动获取对方的mac地址，补齐这封信，并从网卡发送出去。

  ![](ip.png)

---

#### MAC地址

虽然计算机、手机、电视机等是不同类型的电子设备，但它们的通讯都是通过内部的网卡设备来进行。**每张网卡在出厂使都被写入一个MAC地址**。该地址由6个字节构成：前3个字节是网络硬件厂商编号，后3个字节是该厂商所制造的网卡的序列号。所以每个mac地址都是全球唯一的。

---

#### IP地址

IP地址有两种：

- IPV4地址：由4个0~255的数字构成，用小数点间隔开。ipv4地址理论上有42亿个，但由于早期编码和分配的问题，很多区间的编码实际上被空出或不能使用。ipv4地址也在2011年被全部使用。
- IPV6地址：128位。

---

#### DHCP协议

你可能会困惑：我的电脑接上网线，或是手机接上路由器之后，并没有要求我配置IP地址也能正常使用？这是因为**DHCP协议**自动帮我们配置了IP地址。

我们有两种方式配置IP地址：

- 手动配置：自己设置IP地址、子网掩码、默认网关等信息。这种方式的好处在于可以根据自己的规划，设置每台设备的固定IP，有利于网络的统一管理。
- 动态获取：根据DHCP协议，我们根本不需要关心设备的IP是多少，自动分配一个IP就好了。

粗略地讲。当电脑插上网线或是手机连上wifi，操作系统网络协议栈会自动向外发送一包DHCP请求，请求为其分配IP地址。路由器获取到DHCP请求后，会为其分配一个IP地址，并通过DHCP回复报文发送回去。操作系统收到DHCP回包后，将其分配的IP地址配置到网卡上。注意，**在一个 *局域网* 中，IP地址是唯一的**。路由器不会分配重复的IP地址给不同的设备。

![](dhcp.png)

完整流程略有不同。计算机通过网线连接到路由器上，当电脑开机进入操作系统后，此时其还没有IP地址。操作系统会使用UDP协议向外广播 *DHCP Discover数据包* ，寻找DHCP服务器。网络中的所有设备都能会收到这一数据包，但只有DHCP服务器会做出响应。在家庭网络中，路由器就是DHCP服务器。路由器在自己的IP地址池中选出空余的IP，并决定分配给计算机。路由器会把此IP封装成 *DHCP offer包* ，回复给计算机。计算机收到DHCP offer包，需要考虑是否使用该IP。这是因为网络中可能有多个DHCP服务器，它们都收到了计算机的DHCP请求，都为其分配了IP。一般情况下，计算机会使用第一个收到的DHCP offer包。之后，计算机会广播自己的决定，这个数据包称为 *DHCP Request包* 。路由器接收到request包之后，会回复一个 *ACK包* ，表示已接受计算机的选择，并确认此IP可用。

![](dhcp2.png)

前两步并不是必须的。当计算机申请过IP，计算机重启后，计算机无需重新获取IP地址，只需要再次确认就可以了，也就是从第三步开始。

注意，**DHCP协议是应用层协议**。

---

#### ARP协议

我们提到MAC地址是由操作系统来补齐的，那操作系统是怎么知道对方的MAC地址的呢？

在现实中写信，有两个关键的字段需要填写：收件人、收件地址。假设我想给好朋友ter写一封信，但是我不知道收件地址。此时信是寄不到的，怎么办呢？我应该先打电话给ter，询问他的收件地址，再填写到我的信件上。在计算机网络中的通信亦是如此。ARP协议就是帮我们打电话给目标IP并查询它的MAC地址。**ARP协议（地址解析协议）就是通过IP地址来查询MAC地址的协议**。

当计算机A想向计算机B发送信息时：A并不会立即发出，而是先广播一包ARP请求报文，来问一下计算机B的MAC地址是多少。此时网络中的所有设备都收到了这一包请求报文。除了计算机B以外的所有设备都会丢弃这包报文，只有计算机B会回复自己的MAC地址是多少。计算机A收到复后，首先会把计算机B的MAC地址缓存起来，以便下次使用。然后计算机A再将MAC地址添加进报文头部，通过网卡发送出去。

并不是每次发送信息都需查询这个步骤。每次查询到的MAC地址会存入**ARP表**，以便下次使用。只有ARP表中查无此人人时，才会进行查询。

![](arp2.png)

**ARP协议是数据链路层协议**。在被广播的ARP请求报文中，网络层的ARP协议中的目标MAC地址会全填0，表示请求。但数据链路层的目标MAC地址则全是1，表示进行广播。

你可能困惑：现实生活中，我的好朋友ter可能搬家，那搬家之后，我照着之前的地址写信不就寄错了吗？计算机网络中也是同理，尽管MAC地址时固定的，但是IP地址是可以修改的。对此，解决方案也很简单：ter主动向所有人广播自己的新地址。

实际上，**当计算机修改IP地址后，操作系统会主动向网络中广播一包ARP数据包**。此数据包不需要回复，目的是告诉网络中的所有其他主机：当前IP地址和MAC地址的绑定关系。每一台收到ARP数据包的主机，会更新自己的ARP表。

---

#### ARP攻击

假设我们有如下网络。无论是TCP协议还是UDP协议，主机A若想与互联网通信，都要通过路由器。亦即：主机A上的所有数据包的数据链路层的目标MAC地址都是路由器的MAC地址。当然，这个MAC地址也是通过ARP协议查询网关IP得到的。

假设此时网络中的另一台主机C，向网络中广播一包ARP报文。它在报文中伪造其IP地址是网关地址，MAC地址是主机C的MAC地址。这相当于告诉网络中的其他主机：“网关IP在我这里！”于是其他所有主机会更新各自的ARP表，并认为主机C是网关，把数据包发送到主机C。于是，整个网络中的主机都无法连接互联网。这就是**ARP攻击**。

![](attack.png)





### 网络间如何通信

#### 子网划分

我们将**IP地址与子网掩码按位相与**。如果两个IP地址 *与子网掩码相与的结果* 相同，就认为它们在同一子网中。

由于子网掩码都是由连续的1和连续的0组成，我们常用1的数量来表示子网掩码。因此，我们用**IP/子网掩码**来表示一个网络。（常用的子网掩码如255.255.255.0）

如果想扩大网络中IP地址数量，只需调小子网掩码，亦即减少子网掩码中1的个数。反之，如果想缩小网络中IP地址数量，只需调大子网掩码，亦即增加子网掩码中1的个数。（比如：192.168.1.0/24这个网络中有255个IP地址）

![](subnet.png)

---

#### 网关

根据TCP/IP协议，不同子网之间是不能直接通信的。如果要通信，则需要通过网关来进行转发。

网关上有两张网卡，分别配置了属于两个不同子网的IP地址，从而可以在两个网络间转发数据包。

![](customs.png)

 举一个简单的例子。子网1中的计算机a发送数据包时，首先会根据目标IP地址，判断其是否与自己处于同一子网。如果属于同一子网，则直接从计算机a的网卡发出。若不是同一子网，则需要把数据包的目标MAC地址改为网关MAC地址，然后发送给网关。网关拿到数据包后，查询 *路由表* ，知道这包数据属于子网2。网关把目标MAC地址修改计算机b的MAC地址，把源MAC地址修改成自己的MAC地址。然后网卡把数据包从子网2的网卡发出。以上**根据目标IP判断如何发送**的行为，我们称之为“**路由**”。

![](road.png)

---

#### 交换机

**交换机负责把数据包发送到正确的位置**。在写信的例子中，**交换机相当于邮递员**。交换机根据数据包中的目标MAC地址，找到它对应的物理端口。一台交换机有很多个端口，它们有自己的编号。计算机的网卡通过网线连接到交换机的网口上，这样每个端口都是一个确定的物理位置。我们只需要知道某个MAC地址在哪个端口上，就能正确地把数据包发给目标MAC地址。所以在交换机中，有一张端口与MAC地址地映射关系表，交换机维护这个映射关系。

![](postman.png)

每一包数据都有两个MAC地址：源MAC地址（发送方）、目标MAC地址（接收方）。交换机收到一包数据后，首先把这包数据的源MAC与接受端口进行绑定，填入MAC地址表。然后交换机查找目标MAC地址，确定从哪个端口发送出去（发出端口）。如果MAC地址表中查询到了关联端口，则直接从关联端口发出。若没有查找到关联端口，则向除了接受端口外的所有端口群发。这种行为称之为“**泛洪**”。如果目标MAC地址在这个网络中，则它一定能收到群发的数据包。如此运行一段时间后，交换机的MAC地址表就涵盖网络中的所有网卡设备。由此可见，**交换机只关心MAC地址，不关心IP地址**。

![](switch.png)

**MAC地址在TCP/IP协议中处于第二层（数据链路层）**，因此交换机通常也称为二层设备。

---

#### 路由器

**如果忽略路由器的WAN口，那么路由器其实就是一台交换机**。

 路由器有两种接口：

- LAN口：可以多个，用于连接家庭网络设备（比如台式机、手机、笔记本，其中手机、笔记本是通过wifi连接到路由器的）。
- WAN口：只有一个，连接到运营商网络，从而连接到互联网中。

路由器通过LAN口接入内网，通过WAN口接入互联网。它们属于两个不同的子网。所以，从内网访问互联网就是跨网络的行为，这就需要**路由器担任网关的角色**。

---

#### SNAT技术

尽管同一子网中的IP地址互不相同，但是不同子网中的IP地址可能相同。那么当不同家庭内网中的两台计算机拥有相同的IP时，如果它们同时访问互联网，就会造成IP冲突，使得ARP表混乱，使得通信目标变得不确定。为了解决这一问题，我们采用了**源地址转换技术（SNAT）**。

首先计算机发送一包数据，到达路由器。在这包数据的网络层，有两个重要信息：源IP、目标IP。**路由器执行SNAT，将源IP修改成路由器WAN口的公网IP，再将数据包发送到服务器**。服务器收到数据包后进行处理，在发送数据包到路由器，以进行回复。路由器再进行反向SNAT操作，把目标IP修改成计算机a的IP。

![](simpled.png)

这是简化的网络通信模型，真实情况会更复杂一些。

假设同一子网中两台计算机同时访问同一个服务器，服务器会回复两个数据包分别给两台计算机。但两个数据包的源IP都是服务器IP，目标IP都是路由器的公网IP。那么，路由器如何判断两个数据包分别该给谁呢？

所以，只关注IP地址（网络层）是不够的，还需要其他确定性标记。这是就需要把关联的属性扩展到下一层（传输层）。

我们以最常见的 *传输层协议TCP协议* 为例。TCP协议有两个关键的属性：源端口、目标端口。这时我们的SNAT技术就变成：**修改源IP地址和源端口**，并将 *修改后的端口号* 和 *源IP+源端口* 形成映射关系。

![](completed.png)

除了TCP协议以外， *UDP协议* 也是同理：IP地址+端口号。但是ping命令（常用来检查目标联通性）采用的是 *ICMP协议* 。它没有端口信息，则需要使用协议中的type+code，来代替端口进行关联。

![](protocol.png)

---

#### DNAT技术

DNAT名为目标地址转换。顾名思义，DNAT是修改目标地址。

如果我们的内网计算机对外提供服务，公网上发送来的请求不能直接到达内网计算机。我们就需要用DNAT技术向内网转发请求。

假设我们内网的一台主机上有一个web服务，正在监听某个端口。我们需要在路由器上配置一个DNAT，作用为：访问 *公网IP的某个端口* 就转接到 *主机IP的对应端口* 。则当返回问数据包从WAN口进入后，路由器执行DNAT：**修改目标IP、目标端口**。

![](DNAT.png)

DNAT技术和SNAT技术统称为**NAT技术**，将网络一层层分隔开，同时实现不同网络间的通信。

---

#### ICMP协议

ping命令使用ICMP协议，全称：**互联网控制消息协议**。其作用：检测网络中的各种问题，然后做出诊断和解决。它有两大功能：

- 询问报告：询问目标主机是否可以连通，例如`ping`命令。
- 差错报告：当目标网络、或目标端口不可达时，向主机报告错误，例如`traceroute`命令。

`ping`命令执行流程：

- 记录当前时间，并构建ICMP报文。ICMP报文关键字段如下图。其中请求报文的ICMP类型是8。

  ![](icmp.png)

- 操作系统会发送ICMP查询报文。如果目标存在，目标主机会构造一包回复报文，并发送会源主机。回复报文的ICMP类型为0。

- 源主机接收ICMP回复报文。（也可能没有收到回复）

- 再次记录当前时间，并与之前记录的时间做差，计算得到延迟时间。

注意：如果目标主机不存在、或回复报文丢失：源主机则会等待一段时间后超时，报告目标主机无法连通。

![](ping.png)

`ping`命令只能检测两台主机是否连通。而`traceroute`命令可以知道从源主机到目标主机之间经历了哪几个网关的转发、以及这些网关的IP地址。因此，`traceroute`指令可以帮助我们了解复杂网络的拓扑结构。

`traceroute`如何做到的呢？

在网络层的IP数据包头中，有一个**TTL字段：表示此帧数据可经过的最大节点数**。假设发送一帧 TTL = 2 的数据包，则其每经过一个网关，TTL减少1。它到达第二个网关时，TTL = 0。此时网关不能再向前发送数据包，只能丢弃数据包，并通过ICMP协议向源主机报告错误。这即是ICMP的差错报告功能之一。

`traceout`依次发送TTL = 1、2、3……的 *UDP报文* ，源主机通过回复报文依次知道第1、2、3……个网关的IP地址，并计算出其延时。直到TTL为某个值时，UDP报文发送到目标主机。

这时，目标主机既不需要再向前转发，也因TTL = 0而不需要回复ICMP差错报文。那么源主机怎么知道UDP报文已经抵达目标主机呢？

这是由于源主机构造UDP报文时将目标端口设置为一个很大的值，即：一个不存在的目标端口。所以目标主机同样会回复 *因目标端口不可达而产生* 的ICMP差错报文。源主机收到报文后，即可知道目标主机已到达。

![](traceroute.png)





### 传输层协议

#### 通俗理解

**TCP协议**和**UDP协议**都工作在传输层，作用都是**在程序之间传输数据**。数据可以是文本文件、视频、图片。对TCP和UDP来说，数据都是一堆二进制数，并无区别。TCP和UDP之间最大的区别在于：**TCP基于连接，UDP基于非连接**。

做一个简单的比喻。如果把人与人之间的通信比喻为进程与进程之间的通信，我们基本有两种方式：写信、打电话。**TCP是打电话，UDP则是写信**。写信时，我们关心：对方是否收到、内容是否完整、顺序是否正确（当我们寄出多封信时）。但这些都是无法确定的，甚至我们都无法确认收信人、收信地址是真实存在的。与此不同，打电话的整个流程（电话接通、相互通话、通话挂断）都能得到及时的反馈，并且能确认对方准确的接收到。

![](phone.png)

---

#### TCP 协议

TCP有三个关键步骤：**三次握手**、**传输确认**、**四次挥手**。

**三次握手是建立连接的过程**。当客户端向服务端发起连接时，客户端会先发一包数据请求连接，询问能否与服务端建立连接。这包数据称为 *SYN包* 。如果对端同意连接，则回复一包 *SYN+ACK包* 。客户端收到回复后，再发送 *ACK包* ，就能建立连接。因为该过程中相互发送了三包数据，所以称作“三次握手”。

![](handshakes.png)

你可能会困惑：为什么要三次握手而不是两次握手呢？这是为了防止已失效的请求报文突然又传到服务器而引起错误。**三次握手本质上是为了在不可靠的网络信道上建立起可靠的连接**。

举一个简单的例子。假设采用两次握手。假设客户端向服务器发送了SYN1包请求建立连接，但由于某种原因（比如在中间的某个网络结点发生了滞留），SYN1包没有发送到服务器。于是客户端会重新发送SYN2包请求建立连接，这次服务器收到并成功地与客户端建立了连接。之后SYN1包又到达了服务端，服务器会以为是客户端希望建立新的连接，于是发送SYN+ACK包，从而服务端在以上两次握手之后进入等待数据状态。服务端认为是2个连接，而客户端认为是1个连接，造成状态不一致。如果是三次握手，服务端最后收不到客户端发送的ACK包，便不会认为连接建立成功。

![](connect.png)

经历三次握手之后，客户端和服务端都进入数据传输状态。现在有两个问题需要解决：丢包问题（一包数据可能拆成多包数据进行传输）、乱序问题（这些数据包到达的顺序可能不同）。“**传输确认**”就是为解决这些问题。

以下过程不区分客户端、服务端，两端均采用下述机制。

TCP协议为每一个连接建立一个发送缓冲区。从建立连接后的第一个字节的序列号为0，往后每个字节的序列号就会增加1。发送数据时，取一部分数据组成发送报文，在其TCP协议头中会附带：序列号、数据长度。接收端在收到数据后需要回复确认报文，确认报文中的 *ACK = 序列号 + 长度 = 下一包数据的起始序列号* 。如此一问一答的发送方式能让发送端确认数据已经被对方接受。发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK即可。这样发送端可以把数据切割成一系列待发送的碎片，依次发送到对端。根据序列号和长度，对端能重组出完整的数据。即使其中丢失了某些数据包，接收端也可以要求发送端重传，发送 *ACK = 丢失序列包其实序列号* 。

![](confirm.png)

**四次挥手是关闭连接的过程**。客户端和服务端都可以发起关闭连接请求。

假设客户端想关闭连接，它需要向服务端发送一包数据，称为 *FIN包* ，表示要终止连接，然后客户端进入 *终止等待1状态* 。这是第一次挥手。

服务端收到FIN包，回复一包 *ACK包* ，表示自己进入了 *关闭等待状态* 。客户端收到ACK包，进入 *关闭等待2状态* 。这是第二次挥手。此时服务端还可以发送未发送的数据，客户端也还可以接受数据。

当服务端发送完数据后，服务端发送一包FIN包，进入 *最后确认状态* 。这是第三次挥手。

客户端收到FIN包后，回复一包ACK包，进入 *超时等待状态* 。经过超时时间后，客户端关闭连接。而服务端在收到ACK包时，立即关闭连接。

![](wave.png)

你可能会困惑：为什么客户端需要超时时间等待？这是为了确保对方已收到ACK包。**四次挥手也是为了在不可靠的网络链路中实现可靠的连接断开确认**。

举一个简短的例子。假设客户端发送完最后一包ACK包后就释放了连接。一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态。相反，如果客户端在发送完ACK包之后等待一段时间，这时服务端因为没有收到ACK包而重发FIN包。客户端会重发ACK包并刷新超时时间。

---

#### UDP协议

UDP协议发送数据就是**简单地把数据包封装一下，然后从网卡发出去**。数据包之间并没有状态上的联系。

正因为UDP这种简单的处理方式，UDP的性能损耗少，占用CPU资源也少。但对于丢包问题，UDP协议并不能保证。因此，UDP在传输稳定性上不如TCP。综上，**TCP常适用于对网络通讯质量要求较高的场景**：传输文件、发送邮件、浏览网页等；**UDP则适用于对实时性要求较高，但是少量丢包并无大影响的场景**：域名查询、语音通话、视频直播等。

![](contrast.png)





### 应用层协议

#### 万维网

**万维网WWW（World Wide Web）**，是一个遍布 Internet 的信息储藏所，是一种特殊的应用网络。它通过超级链接，将所有的硬件、软件、数据资源连成一个网络，用户可从一个站点轻易地转到另一个站点，非常方便地获取丰富的信息。

WWW服务的基础是**Web页面**，每个服务站点都包括若干个相互关联的页面，每个Web页既可展示文本、图形图像和声音等多媒体信息，又可提供一种特殊的链接点。这种链接点指向一种资源，可以是另一个Web页面、文件、Web站点，这样可使全球范围的WWW服务连成一体。这就是所谓的**超文本和超链接技术**。

超文本实际上是一种解决菜单与信息分离的机制，把可选菜单项嵌入文本中的概念称为“ 超文本” 。超文本技术采用指针连结的网状交叉索引方式，对不同来源的信息加以链接。亦即：**一个超文本文件，含有多个指针，而指针可以指向任何形式的文件**。正是这些指针指向的“纵横交错”，使得分布在本地的和远程的服务器上的文本文件连接在一起。

你可能会混淆：因特网（Internet）和万维网（Web）。它们有何不同呢？Internet本质上是一种广域网，连接着全球计算机。Internet支持各种各样的服务，其中一项则是Web服务。**Web使用URL来定位资源，并用HTML语言渲染出网页**。

---

#### URL

当我们进入一个网页，地址栏就会出现一连串英文字母。它是什么呢？很多人称其为 *网址* ，但这并不准确。这其实是 *URL* 。

URL指**统一资源定位符（Uniform Resource Locator）**，它是用于标识和定位互联网上的资源的地址。URL 包含了访问资源所需的信息，通常包括：

- **协议类型**：以双斜杠为分隔符，常用的有："http" 、"https"。协议部分可以省略，浏览器默认“https”。
- **主机名**：即网址。例如 ："www.google.com"、“101.188.67.134”
- **端口号**：*port* 是服务器在其主机所使用的端口号。一般情况下端口号不需要指定，因为通常这些端口号都有一个默认值。只有当服务器所使用的端口号不是默认的端口号时才需要指定。
- **路径**
- **查询参数等**

![](url.png)

---

#### HTTP协议

HTTP（Hyper Text Transfer Protocol）**超文本传输协议**是万维网客户端进程与服务器端进程交互遵守的协议。它是一个应用层的协议，**使用TCP连接**进行可靠的传输。 HTTP是万维网上资源传送的规则，是万维网能正常运行的基础保障。

HTTP的思想非常简单：客户给服务器发送请求， 服务器向客户发送响应， 在客户和服务器之间的HTTP事务有两种类型：**请求**和**响应**。

---

#### DNS协议

我们知道，IP地址才是每台计算机或服务器的唯一标识，但日常中我们更多地通过**域名**来访问服务器。计算机是如何通过域名知道IP地址的呢？这就是DNS协议（**Domain Name System**）。

通俗地讲。我们每天都用手机进行通信，打电话或者发短信。我们的联系人列表中可能有成千上万个手机号，所以记忆全部手机号是很困难的。于是我们就给每个手机号取名或写备注，比如我的好朋友ter的手机号是54250，则我就给54250取名为ter。下次打电话时，我只需要输入ter，而不需要输入54250，就能通信。这其中，**电话号码就相当于IP地址，联系人名称就相当于域名**。

当我们在浏览器中输入“Google.com”时，浏览器会解析这段网址，从中取出域名，然后组建一包DNS查询报文，并发送到主机的上一级DNS服务器。在开启DHCP协议时，DNS服务器IP地址是会自动获取的。在收到报文后，DNS服务器会在缓存的DNS池中查找域名“Google.com”的记录。如果查无此名，则会再向其更上一级的DNS服务器发送查询报文。最后DNS服务器会返回查找到的IP地址，或者返回“查询失败”。

**浏览器并不是每次输入域名都需要查询其IP**。它会缓存DNS记录，并在一定时间内直接使用这些记录（只有超过一定时间后，才会再次查询）。

DNS服务器有复杂的上下级关系、结构。这里就不展开。

---





