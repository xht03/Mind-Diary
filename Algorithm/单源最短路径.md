---
title: 单源最短路径
date: 2024-12-17 18:05:40
tags:
- original
- notes
categories:
- The Introduction to Algorithm
---

### 理论基础

#### 最短路径

$$
对于有向图 \ G=(V, E) \ 和权重函数 \ w:E \to \mathbb{R} \\
我们定义 \\
路径 p = <v_0, v_1, \ldots , v_k> 的权重为 \
w(p) = \sum_{i=1}^{k}w(v_{i-1},v_i)	\\
节点u和v之间的最短路径权重\delta(u,v)=

\left\{
\begin{array}{l}
\text{min{w(p) : p是从u到v的路径}} \\
\infty
\end{array}
\right.
$$

我们不难证明：**最短路径的子路径也是最短路径。**

---

#### 环路

一条最短路径可以包含环路吗？

1. **最短路径不能包含权重为负值的环路。**

   实际上，整个有向图中都不应该出现负回路。否则经过回路的路径可以通过重复无限次负回路来降低路径的权重，直至权重为负无穷（例如下图中的节点e、f、g）。

   在之后介绍的算法中，我们希望：

   - 如果图中没有负回路，则计算单源最短路径。
   - 如果存在负回路，则侦测并报告其存在。

   ![如果存在负回路](https://ref.xht03.online/202412171848762.png)

2. **最短路径也不能包含权重为正值的环路。**

   这是因为：只要将环路从路径上删除，就可以得到一条与原来路径相同的一条权重更小的路径。

3. 我们假定：**最短路径也不包含权重为0的环路。**

综上，我们可以认为：**最短路径不包含环路。**

---

#### 前驱子图

我们不仅希望直到从源节点到各个节点的最短路径，还希望知道具体的路径怎么走。

由于：最短路径的子路径还是最短路径。

当记录到节点 v 的最短路径时，只需要记录从源节点 s 到 v 的最短路径上的倒数第二个节点，称为：v 的**前驱节点** v.&pi; 。

这样得到的子图，称为：**前驱子图。**
$$
G_{\pi}=(V_{\pi},E_{\pi}) \\
V_{\pi}=\{v \in V: v.{\pi} \ne NIL \} \cup \{s\} \\ E_{\pi}=\{(v.{\pi},v) \in E: v \in V_{\pi} - \{s\}\}
$$
 在之后介绍的算法结束时，**前驱子图将是一颗“最短路径树”。该树包括了从源节点 s 到每个可以从 s 到达的结点的一条最短路径。**

下图是一个前驱子图的实例。

![最小路径树不唯一](https://ref.xht03.online/202412171912837.png)

---

#### 松弛操作

对于每个节点 v，我们除了维护其前驱节点 v.&pi; 。我们还维护一个属性 v.d ，记录源节点 s 到 v 的**最短路径估计**。

在计算单源最短路径前，我们会先**初始化**。伪代码如下：

![初始化](https://ref.xht03.online/202412171942344.png)

我们定义松弛操作如下：

对于边 (u, v) ，我们考虑：是否可以（通过边(u, v)）改善从 s 到 v 的最短路径。

![松弛操作](https://ref.xht03.online/202412171944211.png)

---

### Bellman-Ford算法

#### 算法实现

**Bellman-Ford算法允许边的权重为负值。**

算法步骤如下：

- **初始化**
  使用 `INITIALIZE-SINGLE-SOURCE` 初始化所有顶点的最短路径估计，源点 s 的估计为 0，其他顶点为无穷大。
- **松弛过程**
  - 外层循环运行 |V| - 1 次，以确保每个顶点的最短路径都能被更新。
  - 内层循环遍历每条边 (u, v)，调用 `RELAX` 方法以尝试更新顶点 v 的最短路径估计。
- **负权重环检测**
  - 再次遍历所有边，检查是否存在可以进一步松弛的边。
  - 如果存在，说明图中存在负权重环。

伪代码如下：

```
BELLMAN-FORD(G, s)
1.   // 初始化
2.   INITIALIZE-SINGLE-SOURCE(G, s)
3.
4.	 // 松弛过程
5.   for i = 1 to |V| - 1 do
6.       for each edge (u, v) in G.E
7.           RELAX(u, v, w(u, v))
8.   
9.   // 检测负权重环
10.  for each edge (u, v) in G.E do
11.      if v.d > u.d + w(u, v) then
12.          return FALSE
13.  
14.  return TRUE
```

下图是 Bellman-Ford 算法执行过程。

![执行过程](https://ref.xht03.online/202412172000264.png)

不难证明：**该算法时间复杂度为 O(VE) 。**

---

#### 正确性证明

欲证明 Bellman-Ford 算法的正确性：

- 首先证明：**在没有权重为负值的环路的情况下，该算法正确计算出从源结点可以到达的所有结点之间的最短路径权重。**

  ![证明过程](https://ref.xht03.online/202412172013733.png)

- 再证明：**如果存在负回路，则第 |V| 次循环时，一定会发现还能进一步松弛的边。**

---

#### 有向无环图

**对于有向无环图，Bellman-Ford 算法能在 &Theta;(V+E) 时间内完成。**

步骤如下：

- **拓扑排序**：对图的顶点进行拓扑排序，得到一个线性序列。

  ![拓扑排序](https://ref.xht03.online/202412172037544.png)

- **初始化**：使用 `INITIALIZE-SINGLE-SOURCE` 方法初始化从源节点 s 到其他节点的最短路径估计。

- **松弛操作**：按照拓扑排序的顺序处理每个节点，对于每个节点 u，对所有从 u 出发的边进行松弛操作。

核心改进在于：**此时，松弛过的边不需要在之后的循环中再次考虑。**

具体改进如下：

```
DAG-SHORTEST-PATHS(G, w, s)
1.   topologically sort the vertices of G
2.   INITIALIZE-SINGLE-SOURCE(G, s)
3.   for each vertex u in topologically sorted order do
4.       for each vertex v in G.Adj[u] do
5.           RELAX(u, v, w)
```

|   拓扑排序   |   初始化   |  松弛操作  |     总共     |
| :----------: | :--------: | :--------: | :----------: |
| &Theta;(V+E) | &Theta;(V) | &Theta;(E) | &Theta;(V+E) |

---

### Dijkstra算法

#### 算法实现

**Dijkstra算法要求所有边的权重都为非负值。**

算法步骤如下：

- **初始化**:
  - 为每个顶点设置初始距离为无穷大，源点的距离设置为 0。
  - 创建一个优先队列（或最小堆）来存储未处理的顶点，并将源点加入队列。

- **处理顶点**:
  - 从队列中提取距离最小的顶点 u。
  - 对每个与 u 相邻的顶点 v，检查是否可以通过 u 来更新 v 的最短路径。

- **重复**:
  - 重复步骤 2，直到所有可达的顶点都被处理。

伪代码如下：

```
DIJKSTRA(G, w, s)
1.   INITIALIZE-SINGLE-SOURCE(G, s)
2.   S = {}  		// 初始化已找到最短路径的节点集合
3.   Q = G.V  		// 所有节点加入优先队列 Q
4.   while Q ≠ {}
5.       u = EXTRACT-MIN(Q)
6.       S = S ∪ {u}
7.       for each vertex v in G.Adj[u] do
8.           RELAX(u, v, w)  // 对u的每个邻接节点v执行松弛操作
```

下图是 Dijkstra 算法的执行过程。

![Dijkstra算法的执行过程](https://ref.xht03.online/202412172103377.png)

---

Dijkstra 算法的时间开销依赖于**最小优先队列的实现**。

1. 一般数组

   - `INSERT` 和 `DECREASE-KEY` 用时都为 O(1) 。
   - `EXTRACT-MIN` 用时为 O(V) 。
   - 总用时为：O(V<sup>2</sup>) 。

2. 二叉堆

   - 建堆用时为：O(V) 。

   - `EXTRACT-MIN` 操作的执行时间为 O(lgV) ，总共会执行 |V| 次。
   - `RELAX` 操作会进行 |E| 次，每次可能修改节点的最短距离，即可能执行 `DECREASE-KEY` 操作，其执行时间为 O(lgV) 。
   - **故总时间为：O(E·lgV) 。**

3. 斐波那契堆

   - **总时间可达到：O(V·lgV+E) 。**

---

#### 正确性证明

我们只需证明：
$$
在每次 \ while \ 循环开始前，
对于每个节点 v \in S，有v.d=\delta(s,u)。
$$
**反证法**：
$$
设结点 \ u \ 是第一个在加入到集合 \ S \ 时使得该式不成立的节点。\\
考虑：从 \ s \ 到 \ u \ 的一条最短路径 \ p \ 。\\
考虑路径 \ p \ 上第一个满足 \ y \in V-S \ 的节点y, \\
设 \ x \in S \ 为节点 \ y \ 在路径 \ p \ 上的前驱。\\
我们可以将路径 \ p \ 分解为 \ s \overset{p_1}{\longrightarrow} x \longrightarrow y \overset{p_2}{\longrightarrow} u \ 。
$$
![](https://ref.xht03.online/202412172142640.png)

注意到：
$$
由于：最短路径的子路径仍是最短路径， \\
在将节点 \ u \ 加入到集合 \ S \ 时， y.d=\delta(s,y)
$$
因此：
$$
y.d = \delta(s,y) \le \delta(s,u) \le u.d
$$
但是：
$$
u \ 是每次 \ while \ 循环选出来当前最短距离估计最小的点， \\
则：u.d \le y.d
$$
所以上述不等式链全取等。即：
$$
u.d = \delta(s,u)
$$
这与我们选择的节点 u 相矛盾。

---

### 差分约束

差分约束是一种特殊的线性规划问题。
$$
x_j - x_i \le b_k \\
其中 \ 1 \le i,j \le n , i \ne j , 1 \le k \le m
$$
Bellman-Ford 算法可以解决差分约束问题。

差分约束可以通过有向图（称为：**约束图**）来表示：

- 引入一个额外的节点 v<sub>0</sub> ，从 v<sub>0</sub> 出发能到达所有其他节点，且每条边权重为 0。

- 每个变量对应图中的一个节点。
- 每个差分约束对应图中的一条边，边的权重为约束右边的常数，由减数指向被减数。

![约束图实例](https://ref.xht03.online/202412180830433.png)

不难证明：
$$
如果约束图存在负权重环路，则没有可行解。\\
否则，x = (\delta(v_0,v_1),\delta(v_0,v_2),\ldots,\delta(v_0,v_n)) \ 是一个可行解
$$
**证明：**

- 如果存在负环路，对应不等式求和，即可得到矛盾。

- 如果不存在负环路：
  $$
  对于任意一条边(v_i,v_j) \in E \\
  有 \ \delta(v_0,v_j) \le \delta(v_0,v_i) + w(v_i,v_j) \\
  即 \ \delta(v_0,v_j) - \delta(v_0,v_i) \le w(v_i,v_j)
  $$
  

