---
title: Chapter 1: Source coding (2)
date: 2025-2-19 20:32:50
tags:
- translation
- notes
categories:
- Information and Coding Theory
---

## 1.2 Uniquely Decodable Codes

一个编码 $C$ 是**唯一可解码的**（简称 u.d.），如果对于每个 $t \in T^*$，在 $C$ 下对应至 $S^*$ 的 $S$ 最多只有一个；换句话说，函数 $C: S^* \to T^*$ 是一一对应的，所以 $C$ 的像 $C^*$ 中的每个 $t$ 都可以唯一解码。我们总是假设编码词 $w_i$ 在 $C$ 中是不同的，因为如果 $w_i = w_j$ 且 $i \neq j$，那么 $t = w_i$ 可能表示 $s_i$ 或 $s_j$，这样就导致了编码不唯一可解。

在这个假设下，$C$ 的唯一可解码性的定义是：每当

$$
u_1 u_2 \dots u_m = v_1 v_2 \dots v_n
$$

且 $u_1, \dots, u_m, v_1, \dots, v_n \in C$，我们有 $m = n$ 且对每个 $i$，$u_i = v_i$。  用代数术语来说，意思是，每个编码序列 $t \in C^*$ 都可以唯一地分解为编码词的乘积。

> **定理 1.7**  
> 如果编码 $C$ 中所有编码词 $w_i$ 具有相同的长度，那么 $C$ 是唯一可解码的。

**证明**  
设 $l$ 为编码词的共同长度。如果某个 $t \in C^*$ 可以分解为 $u_1 \dots u_m = v_1 \dots v_n$，其中每个 $u_i, v_j \in C$，那么 $|t| = l m = l n$，所以 $m = n$。现在，$u_1$ 和 $v_1$ 都是 $t$ 的前 $l$ 个符号，因此 $u_1 = v_1$，以此类推，$u_i = v_i$ 对于所有的 $i$。

如果 $C$ 中的所有编码词都有相同的长度 $l$，我们称 $C$ 为长度为 $l$ 的块编码。我们将在第 5.7 章详细研究这种编码。

注意到，定理 1.7 的逆命题是错误的：

> **例 1.8**  
> 由以下给出的二进制编码 $C$ 
>
> $$
> s_1 \mapsto w_1 = 0 , \ s_2 \mapsto w_2 = 01 , \ s_3 \mapsto w_3 = 011
> $$
> 
> 具有可变长度，但仍然是唯一可解码的。在编码中，每个符号 0 表示一个编码词 $w_i$ 的开始，并且 $i$ = 1 + 随后的 1 的数量。
>
> 实际上，我们在这里使用符号 0 作为一个标点符号。

我们将给出一个“编码 $C$ 是唯一可解码的”的**充分必要条件**。我们使用归纳法定义一个非空词集合的序列 $C_0, C_1, \dots$，因此对于所有的 $n$，都有 $C_n \subseteq T^+$。具体地，我们定义 $C_0 = C$，并且对于每个 $n \geq 1$，

$$
C_n = \{ w \in T^+ \mid uw = v, \ \exists u \in C, v \in C_{n-1} \text{ or } u \in C_{n-1}, v \in C \}
$$

我们定义

$$
C_\infty = \bigcup_{n=1}^{\infty} C_n
$$

这个定义一开始可能看起来有些复杂，但如果我们一步一步来，它应该变得会更清晰：我们从 $C_0 = C$ 开始，然后通过它的前一个集合 $C_{n-1}$ 来构造每个 $C_n$（$n \geq 1$），最后我们取 $C_\infty = C_1 \cup C_2 \cup \dots$。注意，对于 $n = 1$，$C_n$ 的定义可以简化：因为 $C_{n-1} = C_0 = C$，所以（式 1.3）中“或”连接的两个条件是相同的，因此

$$
C_1 = \{ w \in T^+ \mid uw = v, \ \exists u, v \in C \text{ 使得 } uw = v \}
$$

还注意到，如果 $C_{n-1} = \emptyset$，则 $C_n = \emptyset$，因此通过迭代我们得到 $C_{n+1} = C_{n+2} = \dots = \emptyset$。

根据 $C_\infty$ 的定义，可以想象构造这个集合可能需要无限多的步骤，对于每个 $n \geq 1$ 都需要构造一个新的集合 $C_n$。练习 1.1 表明了我们总是可以在有限步内构造出 $C_\infty$。

> **练习 1.1**  
> 证明：如果 $C$ 的编码词长度为 $l_1, \dots, l_q$，并且对于某个 $n$ 有 $w \in C_n$，那么 $|w| \geq l = \max(l_1, \dots, l_q)$。从中推导出每个 $C_n$ 是有限的，并且集合序列 $C_0, C_1, \dots$ 是最终周期性的。  
> 
> 这如何帮助我们构造 $C_\infty$？

**证明**
对 $n$ 进行归纳。如果 $n = 0$，则 $C_n = C$，所以 $|w| \leq l$。如果 $n > 0$，则 $uw = v$，其中 $v \in C_{n-1}$ 或 $v \in C$，因此通过归纳或通过定义，$|w| \leq |v| \leq l$。有 $N = r + r^2 + \dots + r^l = \frac{r(r^l - 1)}{r - 1}$ 个非空的 $r$-进制单词 $w$，满足 $|w| \leq l$，因此对于每个 $n$，$|C_n| \leq N$。共有 $2^N$ 个不同的这样的单词集合，因此在集合 $C_0, \dots, C_{2^N}$ 中，必定存在一个重复，$C_i = C_j$ 其中 $i < j \leq 2N$。根据 $C_n$ 定义，每个 $C_n$ 仅依赖于 $C$ 和 $C_{n-1}$，因此对于所有 $k \geq 0$，$C_{j+k} = C_{i+k}$；从而每个 $C_n = C_0$ 或 $C_1$ 或 $\dots$ 或 $C_{j-1}$，因此我们有 $C_\infty = C_0 \cup C_1 \cup \dots \cup C_{j-1}$。此，一旦我们在连续的集合 $C_0, C_1, \dots$ 中找到重复，就完成了对所有 $C_\infty$ 的构造。


我们现在可以给出唯一可解码性的充分必要条件。**Sardinas-Patterson 定理**如下所示。

> **定理 1.10 (Sardinas-Patterson Theorem)**  
> $C$ 是唯一可解码的，当且仅当编码 $C$ 和 $C_\infty$ 是互不相交的。
>
> **另一种表述：**
> 如果一个编码 $C$（即一组编码词）是唯一可解码的，那么 $C$ 中不存在任何编码词能够作为其他编码词的前缀。

由于 Sardinas-Patterson 定理的证明较长，我们将在附录 A 中给出证明；在这里，我们将提供两个典型的论证，以便说明其中涉及的思想。

(=>) 假设 $C_n \cap C_\infty \neq \emptyset$，比如 $w \in C \cap C_2$；因此，$uw = v$，其中 $u \in C$ 且 $v \in C_1$，或者反之。为了简化起见，我们假设第一种情况成立（第二种情况留作练习）。然后 $u'v = v'$，其中 $u', v' \in C$，因此序列 $t = u'uw \in T^*$ 可以表示三个源符号的序列（因为 $u', u, w \in C$），也可以表示一个源符号的序列（因为 $u'uw = u'v = v' \in C$）。因此，解码不是唯一的。

(<=) 假设我们有一个非唯一解码的实例，形式为 $t = u_1u_2 = v_1v_2$，其中 $u_1, u_2, v_1, v_2 \in C$。我们不能有 $|u_1| = |v_1|$，因为这将导致 $u_1 = v_1$，从而得到 $u_2 = v_2$。我们可以假设 $|u_1| > |v_1|$ （如果需要，可以重新编号），因此 $u_1 = v_1w$，其中 $|w| > 0$。然后 $w \in C_1$，所以 $u_2 \in C_2$，因为 $wu_2 = v_2$。因此，$u_2 \in C \cap C_\infty$，所以 $C$ 和 $C_\infty$ 不是互不相交的。

定理 1.10 的证明中的一般论证类似于上述的论证，但它们要复杂得多，因为需要处理无限多种不同的情况。幸运的是，对于另一种重要类型的编码，有一个更简单的充分必要的条件，我们将在下一节中讨论。

我们已经定义了唯一解码性，唯一解码性意味着**所有有限的编码序列 $t$ 都可以唯一解码**，但也可以考虑更强的要求，即所有编码序列，无论是有限还是无限，都应该满足唯一解码性。由 Even、Levenshtein 和 Riley 提出的一个定理表明，当且仅当存在某个 $n \geq 1$ 使得 $C \cap C_\infty = \emptyset$ 且 $C_n = \emptyset$ 时，才能满足这一要求。（这些也是 $C$ **有限延迟的唯一解码性**的充分必要条件，这意味着存在一个常数 $d$，使得如果两个编码序列在前 $d$ 个符号上相同，则它们的第一个编码词也相同；因此，解码可以在最多延迟 $d$ 个符号后开始。我们将在下一节中考虑更强的条件。）

在本书的其余部分，我们将把注意力集中在有限的编码序列上。
