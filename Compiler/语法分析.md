---
title: 语法分析
date: 2025-3-3 13:27:10
tags:
- translation
- notes
categories:
- Modern Compiler Implementation in C
---

## Part 1

### 语法分析器

基本作用：

- 从词法分析器获取词法单元的序列，确认该序列是否可以由语言的文法生成。

- 对于语法错误的程序，报告错误信息。

- 对于语法正确的程序，生成语法分析树（简称**语法树**）。

![](https://ref.xht03.online/202503031342697.png)

分类：

- **自顶向下**的语法分析器：从语法分析树的根节点开始构建。（处理LL文法）

- **自底向上**的语法分析器：从语法分析树的叶子开始构建。（处理LR文法）

这两种分析方法中，语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符号。

---

### 上下文无关文法

一个**上下文无关文法**（CFG）包含四部分：

- **终结符号**：组成串的基本符号（词法单元名字）

- **非终结符号**：表示串的集合的语法变量。

- **开始符号**：某个被指定的非终结符号。它对应的串的集合就是文法的语言。

- **产生式**：描述终结符号、非终结符号组成串的方法。

    - 形式：`头部 -> 体部`

    - 其中`头部`是非终结符号，`体部`是终结符号或非终结符号的串。

    - 例子：`expreression -> expression + term`

所以，一个CFG可以表示为一个四元组：`G = (V, T, S, P)`，其中：

- `V`是非终结符号的集合

- `T`是终结符号的集合

- `S`是开始符号

- `P`是产生式的集合

---

### 推导

通俗理解：将待处理的串中的某个非终结符号替换为该非终结符号的某个产生式的体部。

严格定义：如果 $ A \to \gamma $ 是一个产生式，那么 $ \alpha A \beta \Rightarrow \alpha \gamma \beta $ 是一个推导。

最左推导（leftmost derivation）是一种总是扩展最左边非终结符的推导；在最右推导（rightmost derivation）中，下一个要扩展的非终结符总是最右边的非终结符。

---

### 语法分析树

语法分析树是推导的图形表示形式。语法分析树的每个内部结点表示一个产生式的应用。

- 根结点是文法开始符号。

- 每个叶子结点是非终结符、终结符号或 $\epsilon$。

- 每个内部结点是一个非终结符号，它的子结点是产生式的体部。这表示着一个产生式的应用。

![](image-1.png)

---

### 二义性

如果一个文法可以为某个句子生成**多棵**语法分析树，这个文法就是**二义性**的（ambiguous）。

---

### 文件结束符

语法分析器不仅读入`+`、`-`、`num`这样的终结符号，还要读入**文件结束符**（EOF）。这样，语法分析器就知道何时停止。我们用 `$` 表示文件结束符。

---

## Part 2

### 自顶向下语法分析

自顶向下语法分析算法，也称为预测分析法。它试图从开始符号推导出输入符号串，每次为最左边的非终结符号选择适当的产生式，但有多个可能的产生式时则无能为力。具体来说，就是当两个产生式具有相同前缀时就无法预测了。

基本步骤：

- 确定对句型中 最左边的非终结符号应用哪个产生式。

- 然后对该产生式与输入符号进行匹配。

关键问题：

- 确定对最左边的终结非终结符号应用哪个产生式。

> **例1**
>
> ```
> stmt -> if expr then stmt
> stmt -> if expr then stmt else stmt
> ```
>
> 当我们读入`if expr then`时，我们无法确定是应该使用第一个产生式还是第二个产生式。

> **例2**
> 
> ```
> stmt -> if expr then stmt
> stmt -> if expr then stmt else stmt
> stmt -> other
> ```
>
> ` if E1 then if E2 then S1 else S2` 这个句型有两棵语法分析树：
>
> ![](image-2.png)



---

### FIRST 和 FOLLOW



