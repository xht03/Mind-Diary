---
title: 语法分析
date: 2025-03-03 13:27:10
tags:
- translation
- notes
categories:
- Modern Compiler Implementation in C
---

## Part 1 语法分析概述

### 语法分析器

基本作用：

- 从词法分析器获取词法单元的序列，确认该序列是否可以由语言的文法生成。

- 对于语法错误的程序，报告错误信息。

- 对于语法正确的程序，生成语法分析树（简称**语法树**）。

![](https://ref.xht03.online/202503031342697.png)

分类：

- **自顶向下**的语法分析器：从语法分析树的根节点开始构建。（处理LL文法）

- **自底向上**的语法分析器：从语法分析树的叶子开始构建。（处理LR文法）

这两种分析方法中，语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符号。

---

### 上下文无关文法

一个**上下文无关文法**（CFG）包含四部分：

- **终结符号**：组成串的基本符号（词法单元名字）

- **非终结符号**：表示串的集合的语法变量。

- **开始符号**：某个被指定的非终结符号。它对应的串的集合就是文法的语言。

- **产生式**：描述终结符号、非终结符号组成串的方法。

    - 形式：`头部 -> 体部`

    - 其中`头部`是非终结符号，`体部`是终结符号或非终结符号的串。

    - 例子：`expreression -> expression + term`

所以，一个CFG可以表示为一个四元组：`G = (V, T, S, P)`，其中：

- `V`是非终结符号的集合

- `T`是终结符号的集合

- `S`是开始符号

- `P`是产生式的集合

---

### 推导

通俗理解：将待处理的串中的某个非终结符号替换为该非终结符号的某个产生式的体部。

严格定义：如果 $ A \to \gamma $ 是一个产生式，那么 $ \alpha A \beta \Rightarrow \alpha \gamma \beta $ 是一个推导。

最左推导（leftmost derivation）是一种总是扩展最左边非终结符的推导；在最右推导（rightmost derivation）中，下一个要扩展的非终结符总是最右边的非终结符。

---

### 语法分析树

语法分析树是推导的图形表示形式。语法分析树的每个内部结点表示一个产生式的应用。

- 根结点是文法开始符号。

- 每个叶子结点是非终结符、终结符号或 $\epsilon$。

- 每个内部结点是一个非终结符号，它的子结点是产生式的体部。这表示着一个产生式的应用。

![](https://ref.xht03.online/202503042220757.png)

---

### 二义性

如果一个文法可以为某个句子生成**多棵**语法分析树，这个文法就是**二义性**的（ambiguous）。

---

### 左递归

如果一个文法中有非终结符号 $A$，使得 $A \xRightarrow{\text{+}} A\alpha$，那么这个文法就是**左递归**的。特别地，如果文法中存在形如 $A \to A\alpha$ 的产生式，那么这个文法就是**立即左递归**的。

---

### 文件结束符

语法分析器不仅读入`+`、`-`、`num`这样的终结符号，还要读入**文件结束符**（EOF）。这样，语法分析器就知道何时停止。我们用 `$` 表示文件结束符。

---

## Part 2 自顶向下语法分析

### 自顶向下语法分析

自顶向下语法分析算法，也称为**预测分析法**。它试图从开始符号推导出输入符号串，每次为最左边的非终结符号选择适当的产生式，但有多个可能的产生式时则无能为力。

基本步骤：

- 确定对句型中 最左边的非终结符号应用哪个产生式。

- 然后对该产生式与输入符号进行匹配。

关键问题：

- 确定对最左边的终结非终结符号应用哪个产生式。

实现该算法所用到的信息，可以用一张关于产生式的二维表来表示。这张表称为**预测分析表**(predictive parsing table)。

---

### FIRST 和 FOLLOW 集合

构造预测分析表之前，我们先定义两个集合：

- **FIRST**($\alpha$)：给定一个由终结符和非终结符组成的字符串 $\alpha$ ，FIRST($\alpha$)是可以从 $\alpha$ 推导出的任意字符串中开头终结符组成的集合。

- **FOLLOW**($A$)： 可能紧跟 $A$ 右边的终结符号的集合。

计算 **FIRST(X)** 的方法：

1. 如果 $X$ 是终结符号，那么 FIRST($X$) = {$X$}。

2. 如果 $X$ 是非终结符号，且 $X \to \gamma_1\gamma_2 \dots \gamma_k$ 是一个产生式，

    - 如果终结字符 a 在 FIRST($\gamma_i$) 中，且 $\epsilon$ 也在 FIRST($\gamma_1$)，……，FIRST($\gamma_{i-1}$) 中，那么 a 也在 FIRST($X$) 中。

    - 如果 $\epsilon$ 在 FIRST($\gamma_1$)，……，FIRST($\gamma_{k}$) 中，那么 $\epsilon$ 也在 FIRST($X$) 中。

3. 如果 $X$ 是非终结符号，且 $X \to \epsilon$ 是一个产生式，那么 $\epsilon \in$ FIRST($X$)。

计算 **FOLLOW(A)** 的方法：

1. 将文件结束符号 $\$$ 加入到 FOLLOW(S) 中，其中 S 是开始符号。

2. 按如下两条规则不断迭代，知道所有的 FOLLOW 集合不再变化：

    - 如果有一个产生式 $A \to \alpha B \beta$，那么 FIRST($\beta$) 中的所有非 $\epsilon$ 终结符号都加入 FOLLOW($B$) 中。

    - 如果有一个产生式 $A \to \alpha B$ 或 $A \to \alpha B \beta$，那么 FOLLOW($A$) 中的所有终结符号都加入 FOLLOW($B$) 中。

> **例1**
>
> 考虑下面的文法：
> 
> ```
> Z -> d    Y ->     X -> Y
> 
> Z -> XYZ  Y -> c   X -> a
> ```
> 
> 我们不难计算出它的 FIRST 和 FOLLOW 集合：
>
> |    |  FIRST  | FOLLOW  | nullable |
> |----|---------|---------|----------|
> | X  | {a,c}   | {a,c,d} |  yes     |
> | Y  | {c}     | {a,c,d} |  yes     |
> | Z  | {a,c,d} | {$}     |  no      |
>
> 最后一列表示该非终结符号是否可以推导出 $\epsilon$。

---

### 预测分析表

考虑一个预测分析器。非终结符 $X$ 可能有多个产生式，因此，分析器必须根据下一个输入字符 $T$ 来选择其中的一个合适的产生式，来进行语法分析。如果能够为每一个 $(X, T)$ 选择
出正确的产生式，就能够写出这个预测分析器。

为此，我们构造一张以文法的非终结符 $X$ 和终结符 $T$ 作为索引的表，并称为**预测分析表**(predictive parsing table)。

构造预测分析表的方法：

1. 对于每一个产生式 $A \to \alpha$，

    - 对于每一个 $a \in$ FIRST($\alpha$)，将 $A \to \alpha$ 加入到 M[A, a] 中。

    - 如果 $\epsilon \in$ FIRST($\alpha$)，那么对于每一个 $b \in$ FOLLOW($A$)，将 $A \to \alpha$ 加入到 M[A, b] 中。

2. 最后在所有空白的 M[A, a] 中填入错误标记 $error$ 。

> **例2**
> 
> 考虑例1中的文法：
>
> ```
> Z -> d    Y ->     X -> Y
> 
> Z -> XYZ  Y -> c   X -> a
> ```
>
> 预测分析表如下：
>
> |    | a          | c          | d                 |
> |----|------------|------------|-------------------|
> | X  | X->a, X->Y | X->Y       | X->Y              |
> | Y  | Y->        | Y-> , Y->c | Y->               |
> | Z  | Z->XYZ     | Z->XYZ     | Z -> d, Z->XYZ    |

例2中的预测分析表中存在 M[A, a] 中有多个产生式的情况，这意味着文法不能进行预测分析。如果我们进一步检查，就会发现例2中的语法是二义性的。比如句子 `d` 就有多个语法树：

![](https://ref.xht03.online/202503042220757.png)

二义性文法总是会导致预测分析表有多重定义的项，所以我们需要消除二义性。

若文法的预测分析表不含多重定义的项，则称其为**LL(1)文法**。LL（1）代表从左至右分析、最左推导和超前查看一个符号（Left-to-right parse，Leftmost-derivation，1-symbol lookahead）。之所以这么命名，是因为：预测分析器在将非终结符扩展成它们的产生式的右部符号所遵循的顺序恰好就是最左推导扩展非终结符所采用的顺序。

类似地可以定义 LL(k) 文法，其中 k 代表超前查看的符号数。但是由于 $k \ge 2$ 的情况下，预测分析表会变得非常大，所以 LL(1) 文法是最常用的。

---

### 消除二义性

> **例3**
>
> 我们继续考虑上面的文法，现在我们有一个句型`if E1 then if E2 then S1 else S2`。
> 
> ```
> stmt -> if expr then stmt
> stmt -> if expr then stmt else stmt
> stmt -> other
> ```
>
> 这个句型有两棵语法分析树：
>
> ![](https://ref.xht03.online/202503042223554.png)
>
> 也即是说，这个文法是二义性的。为了消除二义性，我们可以如下修改文法：
>
> ```
> stmt -> matched_stmt | open_stmt
>
> matched_stmt -> if expr then matched_stmt else matched_stmt 
>               | other
>
> open_stmt -> if expr then stmt 
>            | if expr then matched_stmt else open_stmt
> ```
>
> 这样，我们就消除了二义性。但是，很可惜，**二义性的消除方法没有规律可循**。

---

### 消除左递归

自顶向下的语法分析技术，不仅需要消除**二义性**，还需要消除**左递归**。

自顶向下的语法分析技术不能处理左递归的情况，因此需要消除左递归，但是自底向上的技术可以处理左递归。

> **例4**
>
> 考虑下面的文法：
>
> ```
> E -> E + T
> E -> T
> ```
>
> 左递归一定会导致 LL(1) 的预测分析表中有多重定义的项。因为 FIRST($E$) 包含了 FIRST($T$)。
>
> 为了消除左递归，我们利用**右递归**来重写产生式，引入新的非终结符号 $E'$：
>
> ```
> E -> TE'
> E' -> +TE'
> E' -> ε
> ```

一般地，对于产生式 $X \to X\gamma$，$X \to \alpha$，其中 $\alpha$ 不以 $X$ 开头，我们知道它们推导出来的字符串形如 $\alpha \gamma^*$。所以，我们可以利用右递归重写：

- $X \to \alpha X'$

- $X' \to \gamma X'$

- $X' \to \epsilon$

---

### 提取左因子

左递归的存在会使得预测分析表中有多重定义的项。除此以外，当**一个非终结符的两个产生式以相同的符号开始**时，也会发生类似的问题。这时就需要：**提取左因子**。

> **例5**
>
> ```
> S -> if E then S
> S -> if E then S else S
> ```
>
> 当我们读入`if E then`时，我们无法确定是应该使用第一个产生式还是第二个产生式。所以，这个文法是二义性的。
>
> 在这种情况下，我们可以提取左因子：
>
> ```
> S -> if E then S X
> X -> else S
> X -> ε
> ```

提取左因子并不能消除二义性。提取之后的文法仍然是二义性的，预测分析表中仍然会有多重定义的项。但是，提取左因子之后，我们可以通过其他方法消除二义性。

---

## Part 3 自底向上语法分析

### LR 语法分析 

LL(k) 分析技术的一个弱点是，它在仅仅看到右部的前 k 个单词时就必须预测要使用的是哪一个产生式。

另一种更有效的分析方法是 LR(k) 分析，LR(k) 并不仅依赖于看前 k 个符号来预测，而是通过栈中已经扫描的符号（可能多于 k 个），并结合 k 个前瞻符号，确定是否可以将当前栈内容归约为某个产生式。

LR(k) 代表**从左至右分析、最右推导、超前查看 k 个单词**（Left-to-right parse，Rightmostderivation，k-token lookahead）。

LL(k) 分析器，维护一个栈和一个输入。输入中的前 k 个单词为**超前查看**的单词。根据栈的内容和超前查看的单词，分析器执行**移进**和**归约**两种动作。

- **移进**：将下一个输入符号移到栈顶。

- **归约**：选择一个产生式 $ X \to ABC $，依次从栈中弹出 $C$、$B$、$A$，然后将 $X$ 压入栈中。

开始时栈为空，分析器位于输入的开始。移进文件终结符 $\$$ 的动作称为**接收（accepting）**，它表明分析过程成功结束。

---

### LR(0) 分析器

LR(k) 分析器利用栈中的内容和输入中的前 k 个单词来确定下一步采取什么动作。LR(k) 分析器利用栈中的内容和输入中的前k个单词来确定下一步采取什么动作。在实际中，编译器并不使用 k>1 的表，在一定程度上是因为这个表十分巨大，但更主要的是因为程序设计语言可以用 LR(1) 文法来描述。

LR(0) 文法是一种只需查看栈就可进行分析的文法，它的移进/归约判断不需要任何超前查看。尽管这一类文法太弱以至于不是很有用，但构造 LR(0) 分析表的算法对于构造 LR(1) 分析器的算法来说是一个很好的开始。

LR(0) 分析器的算法过程如下：

- 查看栈顶状态和输入符号，查表得到动作。

- 如果动作是：

    - 移进（n）：前进至下一单词，将n压入栈中。

    - 归约（k）：从栈顶依次弹出单词，弹出单词的次数与规则 k 右部符号个数相同；令 $X$ 为规则 k 的左部符号，在栈顶现在所处的状态下，查看 $X$ 的 GOTO 函数值，执行对应的动作“转换到状态 n”，将 n 压入栈中。

    - 接受：停止分析，报告成功。

    - 错误：停止分析，报告失败。

---

### 项、CLOSURE 和 GOTO

首先我们引入三个概念：

1. **项（item）**：一个项是一个产生式，它的右部的某个位置被一个小圆点标记。比如，对于产生式 $A \to \alpha B \beta$，项有 $A \to \alpha \cdot B \beta$。圆点指出了分析器的当前位置。

2. **闭包（CLOSURE）**：如果 $I$ 是文法 $G$ 的项集，那么 CLOSURE($I$) 是根据以下两条规则从 $I$ 中的项生成的项集：

    - 将 $I$ 中的各项加入到 CLOSURE($I$) 中。

    - 如果 $A \to \alpha \cdot B \beta$ 在 $I$ 中，且 $B \to \gamma$ 是一个产生式，项 $B \to \cdot \gamma$ 不在 $CLOSURE(I)$ 中，那么将 $B \to \cdot \gamma$ 加入到 CLOSURE($I$) 中。不断应用此规则，直到没有新的项可以加入。

3. **GOTO函数**：如果 $I$ 是文法 $G$ 的项集，$X$ 是一个**文法符号**，那么 GOTO($I$, $X$) 是从 $I$ 中所有形如 $A \to \alpha \cdot X \beta$ 的项所对应的项 $A \to \alpha X \cdot \beta$ 组成的项集的**闭包**。

> **计算 CLOSURE(I) 的算法如下：**
>
> ```
> CLOSURE(I) =
> repeat
>     for I 中的任意项 A -> α·Xβ
>         for 任意产生式 X -> γ
>             I <- I ∪ {X -> ·γ}
> until I 不再改变
> return I
> ```

> **计算 GOTO(I, X) 的算法如下：**
>
> ```
> GOTO(I, X) =
>     J <- {}
>     for I 中的任意项 A -> α·Xβ
>         J <- J ∪ {A -> αX·β}
>     return CLOSURE(J)
> ```

---

### 构造 LR(0) 分析器

LR(0) 分析器本质上是一个有限自动机，它的状态是项集的集合。LR(0) 分析器的构造算法如下：

1. 每一个项集（闭包）对应 LR(0) 分析器的一个状态。

2. 开始状态为 $CLOSURE(\{S' \to \cdot S\})$。这里假设 S 是文法的开始符号，S' 是一个新的辅助的开始符号。

3. 状态转换：如果 $GOTO(I, X) = J$，那么在状态 I 中读入 X 后，分析器转移到状态 J。

> **例6**
>
> 考虑下面的文法：
>
> |   | 产生式    |
> |---|----------|
> | 0 | S' -> S$ |
> | 1 | S -> (L) |
> | 2 | S -> x   |
> | 3 | L -> S   |
> | 4 | L -> L,S |
>
> 我们可以构造 LR(0) 分析器的状态转换图如下：
>
> ![](https://ref.xht03.online/202503101451622.png)
>
> 我们可以构造 LR(0) 分析表如下：
>
> ![](https://ref.xht03.online/202503101504471.png)

根据状态转换图，我们可以构造 **LR(0) 分析表**。LR(0) 分析表的构造方法如下：

1. 以状态号作为行标题，以文法符号作为列标题。

2. 对于每一条边 $I \xrightarrow{X} J$，若 $X$ 是终结符号，则在表中 (I, X) 处填入动作“移进 J”。若 $X$ 是非终结符号，则在表中 (I, X) 处填入动作“转换 J”。

3. 对于包含项 $A \to \alpha \cdot$ （圆点位于尾部的产生式 n）的状态，那么，对于每一个单词 $Y$，填入动作“归约 n”。

4. 对于包含项 $S' \to S \cdot \$ $ 的状态，填入动作“接受”。

---

### SLR 分析器

> **例7**
>
> 考虑下面的文法：
>
> |   |   产生式    |
> |---|------------|
> | 0 | S' -> E$   |
> | 1 | E -> T + E |
> | 2 | E -> T     |
> | 3 | T -> x     |
>
> 我们可以构造 LR(0) 分析器如下：
>
> ![](https://ref.xht03.online/202503101533179.png)
>
> 在状态 3，对于符号 +，我们既可以移进到状态 4，也可以归约到产生式 2。这就是一个冲突。这表明该文法不是 LR(0) 文法 —— 它不能用 LR(0) 分析器来分析。
>
> 我们可以构造更强 SLR 分析器如下：
>
> ![](https://ref.xht03.online/202503101544964.png)

SLR 分析器是一种比 LR(0) 分析器更强的分析器。SLR 分析器的构造几乎与 LR(0) 分析器相同，但是它只在 FOLLOW 集合中指定的地方填入归约动作。

具体来说：

- 对于每一个状态，包含项 $A \to \alpha \cdot$ ，对于每一个 $b \in$ FOLLOW($A$)，填入动作“归约 n”。

---

### LR(1) 分析器

比 SLR 更强大的是 LR(1) 分析算法。大多数用上下文无关文法描述其语法的程序设计语言都有一个 LR(1) 文法。

构造 LR(1) 分析表的算法与构造 LR(0) 分析表的算法类似，但是 项、CLOSURE 和 GOTO 的定义更复杂些：

1. **LR(1) 项**：由一个文法产生式、一个右部位置（用圆点表示）和一个超前查看的符号组成。形如 $(A \to \alpha \cdot \beta, a)$ 。

2. **CLOSURE(I)**：

    ```
    CLOSURE(I) =
    repeat
        for I 中的任意项 (A -> α·Xβ, z)
            for 任意产生式 X -> γ
                for 任意 w ∈ FIRST(βz)
                    I <- I ∪ {(X -> ·γ, w)}
    until I 不再改变
    return I
    ```

3. **GOTO(I, X)**：

    ```
    GOTO(I, X) =
        J <- {}
        for I 中的任意项 (A -> α·Xβ, z)
            J <- J ∪ {(A -> αX·β, z)}
        return CLOSURE(J)
    ```

开始状态为 $ CLOSURE (S' \to \cdot S\$, \ ?) $ ，其中 ? 表示具体是什么不重要，因为文件结束符一定不会被移进。

归约动作如下填入：

- 对于每一个状态 I，包含项 $(A \to \alpha \cdot, z)$，填入动作“归约 n”。

> **例8**
>
> 考虑下面的文法：
>
> |   | 产生式      |
> |---|------------|
> | 0 | S' -> S$   |
> | 1 | S -> V = E |
> | 2 | S -> E     |
> | 3 | E -> V     |
> | 4 | V -> x     |
> | 5 | V -> *E    |
>
> 我们可以构造 LR(1) 分析器如下：
>
> ![](https://ref.xht03.online/202503101814854.png)
>
> ![](https://ref.xht03.online/202503101815456.png)

---

### LALR 分析表

LR(1) 分析表有很多状态，因此会非常大。然而，通过合并那种**除超前查看符号集合外其余部分都相同**的两个状态，可得到一个较小的表。由此得到的分析器称为 **LALR(1) 分析器**，即：Look-Ahead LR(1) 。

对于某些文法，LALR(1) 表含有**归约-归约冲突**，而在 LR(1) 表中却没有这种冲突。不过，实际中这种不同的影响很小，重要的是和 LR(1) 表相比，LALR(1) 分析表的状态要少得多，因此它需要的存储空间要少于 LR(1) 表。

如果一个文法的 LALR(1) 分析表不含冲突，则称该文法是 **LALR(1) 文法**。

> **例9**
>
> 仍考虑例8中的文法：
>
> 如果忽略超前查看的符号集合，状态 6 和状态 13 的项是一样的；状态 7 和状态 12 也是相同的；状态 8 和状态 11；以及状态 10 和状态 14 也都如此。
>
> 我们可以构造 LALR(1) 分析表如下：
>
> ![](https://ref.xht03.online/202503101824055.png)

## Part 4 各类文法层次

![](https://ref.xht03.online/202503101828400.png)