---
title: 语法分析
date: 2025-3-3 13:27:10
tags:
- translation
- notes
categories:
- Modern Compiler Implementation in C
---

## Part 1 语法分析概述

### 语法分析器

基本作用：

- 从词法分析器获取词法单元的序列，确认该序列是否可以由语言的文法生成。

- 对于语法错误的程序，报告错误信息。

- 对于语法正确的程序，生成语法分析树（简称**语法树**）。

![](https://ref.xht03.online/202503031342697.png)

分类：

- **自顶向下**的语法分析器：从语法分析树的根节点开始构建。（处理LL文法）

- **自底向上**的语法分析器：从语法分析树的叶子开始构建。（处理LR文法）

这两种分析方法中，语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符号。

---

### 上下文无关文法

一个**上下文无关文法**（CFG）包含四部分：

- **终结符号**：组成串的基本符号（词法单元名字）

- **非终结符号**：表示串的集合的语法变量。

- **开始符号**：某个被指定的非终结符号。它对应的串的集合就是文法的语言。

- **产生式**：描述终结符号、非终结符号组成串的方法。

    - 形式：`头部 -> 体部`

    - 其中`头部`是非终结符号，`体部`是终结符号或非终结符号的串。

    - 例子：`expreression -> expression + term`

所以，一个CFG可以表示为一个四元组：`G = (V, T, S, P)`，其中：

- `V`是非终结符号的集合

- `T`是终结符号的集合

- `S`是开始符号

- `P`是产生式的集合

---

### 推导

通俗理解：将待处理的串中的某个非终结符号替换为该非终结符号的某个产生式的体部。

严格定义：如果 $ A \to \gamma $ 是一个产生式，那么 $ \alpha A \beta \Rightarrow \alpha \gamma \beta $ 是一个推导。

最左推导（leftmost derivation）是一种总是扩展最左边非终结符的推导；在最右推导（rightmost derivation）中，下一个要扩展的非终结符总是最右边的非终结符。

---

### 语法分析树

语法分析树是推导的图形表示形式。语法分析树的每个内部结点表示一个产生式的应用。

- 根结点是文法开始符号。

- 每个叶子结点是非终结符、终结符号或 $\epsilon$。

- 每个内部结点是一个非终结符号，它的子结点是产生式的体部。这表示着一个产生式的应用。

![](https://ref.xht03.online/202503042220757.png)

---

### 二义性

如果一个文法可以为某个句子生成**多棵**语法分析树，这个文法就是**二义性**的（ambiguous）。

---

### 左递归

如果一个文法中有非终结符号 $A$，使得 $A \xRightarrow{\text{+}} A\alpha$，那么这个文法就是**左递归**的。特别地，如果文法中存在形如 $A \to A\alpha$ 的产生式，那么这个文法就是**立即左递归**的。

---

### 文件结束符

语法分析器不仅读入`+`、`-`、`num`这样的终结符号，还要读入**文件结束符**（EOF）。这样，语法分析器就知道何时停止。我们用 `$` 表示文件结束符。

---

## Part 2 自顶向下语法分析

### 自顶向下语法分析

自顶向下语法分析算法，也称为**预测分析法**。它试图从开始符号推导出输入符号串，每次为最左边的非终结符号选择适当的产生式，但有多个可能的产生式时则无能为力。

基本步骤：

- 确定对句型中 最左边的非终结符号应用哪个产生式。

- 然后对该产生式与输入符号进行匹配。

关键问题：

- 确定对最左边的终结非终结符号应用哪个产生式。

实现该算法所用到的信息，可以用一张关于产生式的二维表来表示。这张表称为**预测分析表**(predictive parsing table)。

---

### FIRST 和 FOLLOW 集合

构造预测分析表之前，我们先定义两个集合：

- **FIRST**($\alpha$)：给定一个由终结符和非终结符组成的字符串 $\alpha$ ，FIRST($\alpha$)是可以从 $\alpha$ 推导出的任意字符串中开头终结符组成的集合。

- **FOLLOW**($A$)： 可能紧跟 $A$ 右边的终结符号的集合。

计算 **FIRST(X)** 的方法：

1. 如果 $X$ 是终结符号，那么 FIRST($X$) = {$X$}。

2. 如果 $X$ 是非终结符号，且 $X \to \gamma_1\gamma_2 \dots \gamma_k$ 是一个产生式，

    - 如果终结字符 a 在 FIRST($\gamma_i$) 中，且 $\epsilon$ 也在 FIRST($\gamma_1$)，……，FIRST($\gamma_{i-1}$) 中，那么 a 也在 FIRST($X$) 中。

    - 如果 $\epsilon$ 在 FIRST($\gamma_1$)，……，FIRST($\gamma_{k}$) 中，那么 $\epsilon$ 也在 FIRST($X$) 中。

3. 如果 $X$ 是非终结符号，且 $X \to \epsilon$ 是一个产生式，那么 $\epsilon \in$ FIRST($X$)。

计算 **FOLLOW(A)** 的方法：

1. 将文件结束符号 $\$$ 加入到 FOLLOW(S) 中，其中 S 是开始符号。

2. 按如下两条规则不断迭代，知道所有的 FOLLOW 集合不再变化：

    - 如果有一个产生式 $A \to \alpha B \beta$，那么 FIRST($\beta$) 中的所有非 $\epsilon$ 终结符号都加入 FOLLOW($B$) 中。

    - 如果有一个产生式 $A \to \alpha B$ 或 $A \to \alpha B \beta$，那么 FOLLOW($A$) 中的所有终结符号都加入 FOLLOW($B$) 中。

> **例1**
>
> 考虑下面的文法：
> 
> ```
> Z -> d    Y ->     X -> Y
> 
> Z -> XYZ  Y -> c   X -> a
> ```
> 
> 我们不难计算出它的 FIRST 和 FOLLOW 集合：
>
> |    |  FIRST  | FOLLOW  | nullable |
> |----|---------|---------|----------|
> | X  | {a,c}   | {a,c,d} |  yes     |
> | Y  | {c}     | {a,c,d} |  yes     |
> | Z  | {a,c,d} | {$}     |  no      |
>
> 最后一列表示该非终结符号是否可以推导出 $\epsilon$。

---

### 预测分析表

考虑一个预测分析器。非终结符 $X$ 可能有多个产生式，因此，分析器必须根据下一个输入字符 $T$ 来选择其中的一个合适的产生式，来进行语法分析。如果能够为每一个 $(X, T)$ 选择
出正确的产生式，就能够写出这个预测分析器。

为此，我们构造一张以文法的非终结符 $X$ 和终结符 $T$ 作为索引的表，并称为**预测分析表**(predictive parsing table)。

构造预测分析表的方法：

1. 对于每一个产生式 $A \to \alpha$，

    - 对于每一个 $a \in$ FIRST($\alpha$)，将 $A \to \alpha$ 加入到 M[A, a] 中。

    - 如果 $\epsilon \in$ FIRST($\alpha$)，那么对于每一个 $b \in$ FOLLOW($A$)，将 $A \to \alpha$ 加入到 M[A, b] 中。

2. 最后在所有空白的 M[A, a] 中填入错误标记 $error$ 。

> **例2**
> 
> 考虑例1中的文法：
>
> ```
> Z -> d    Y ->     X -> Y
> 
> Z -> XYZ  Y -> c   X -> a
> ```
>
> 预测分析表如下：
>
> |    | a          | c          | d                 |
> |----|------------|------------|-------------------|
> | X  | X->a, X->Y | X->Y       | X->Y              |
> | Y  | Y->        | Y-> , Y->c | Y->               |
> | Z  | Z->XYZ     | Z->XYZ     | Z -> d, Z->XYZ    |

例2中的预测分析表中存在 M[A, a] 中有多个产生式的情况，这意味着文法不能进行预测分析。如果我们进一步检查，就会发现例2中的语法是二义性的。比如句子 `d` 就有多个语法树：

![](https://ref.xht03.online/202503042220757.png)

二义性文法总是会导致预测分析表有多重定义的项，所以我们需要消除二义性。

若文法的预测分析表不含多重定义的项，则称其为**LL(1)文法**。LL（1）代表从左至右分析、最左推导和超前查看一个符号（Left-to-right parse，Leftmost-derivation，1-symbol lookahead）。之所以这么命名，是因为：预测分析器在将非终结符扩展成它们的产生式的右部符号所遵循的顺序恰好就是最左推导扩展非终结符所采用的顺序。

类似地可以定义 LL(k) 文法，其中 k 代表超前查看的符号数。但是由于 $k \ge 2$ 的情况下，预测分析表会变得非常大，所以 LL(1) 文法是最常用的。

---

### 消除二义性

> **例3**
>
> 我们继续考虑上面的文法，现在我们有一个句型`if E1 then if E2 then S1 else S2`。
> 
> ```
> stmt -> if expr then stmt
> stmt -> if expr then stmt else stmt
> stmt -> other
> ```
>
> 这个句型有两棵语法分析树：
>
> ![](https://ref.xht03.online/202503042223554.png)
>
> 也即是说，这个文法是二义性的。为了消除二义性，我们可以如下修改文法：
>
> ```
> stmt -> matched_stmt | open_stmt
>
> matched_stmt -> if expr then matched_stmt else matched_stmt 
>               | other
>
> open_stmt -> if expr then stmt 
>            | if expr then matched_stmt else open_stmt
> ```
>
> 这样，我们就消除了二义性。但是，很可惜，**二义性的消除方法没有规律可循**。

---

### 消除左递归

自顶向下的语法分析技术，不仅需要消除**二义性**，还需要消除**左递归**。

自顶向下的语法分析技术不能处理左递归的情况，因此需要消除左递归，但是自底向上的技术可以处理左递归。

---

### 提取左因子

> **例2**
>
> ```
> stmt -> if expr then stmt
> stmt -> if expr then stmt else stmt
> ```
>
> 当我们读入`if expr then`时，我们无法确定是应该使用第一个产生式还是第二个产生式。所以，这个文法是二义性的。





---

### FIRST 和 FOLLOW



